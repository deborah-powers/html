<!DOCTYPE html><html><head>
	<title>éssais avec web gl</title>
	<base target='_blank'/>
	<meta charset='utf-8'/>
	<meta name='viewport' content='width=device-width, initial-scale=1'/>
	<meta name='subject' content='loisir'/>
	<meta name='author' content='deborah'/>
	<meta name='link' content='o'/>
	<link rel='stylesheet' type='text/css' href='file:///C:/wamp64/www/site-dp/library-css/structure.css'/>
	<link rel='stylesheet' type='text/css' href='file:///C:/wamp64/www/site-dp/library-css/perso.css' media='screen'/>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
		integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
		crossorigin="anonymous" defer>
	</script>
</head><style type='text/css'>
	canvas {
		border: solid 4px var(--text-color);
		background-color: var(--fond-color);
		width: 100%;
		height: 20em;
	}
	h2 { border: none; }
</style><body>
	<canvas></canvas>
	<h2>sources</h2>
	<ul aria-label='sources'>
		<li><a href='https://developer.mozilla.org/fr/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL'>créer un contexte web gl</a></li>
		<li><a href='https://developer.mozilla.org/fr/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context'>dessin 2d</a></li>
		<li><a href=''></a></li>
	</ul>
</body><script type='text/javascript'>
const canvas = document.getElementsByTagName ('canvas')[0];
const contextGl = canvas.getContext ('webgl');
contextGl.clearColor (0.0, 1.0, 1.0, 1.0);	// préciser la couleur de fond
contextGl.clear (contextGl.COLOR_BUFFER_BIT | contextGl.DEPTH_BUFFER_BIT);	// apposer la couleur de fond dans le canvas

// dessin 2D, utilisation des shaders
const shaderSommetSrc =`
attribute vec4 aVertexPosition;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
void main(){ gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; }`;
const shaderFragmentSrc = 'void main(){ gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); }';
function loadShader (contextGl, type, source){
	const shader = contextGl.createShader (type);
	contextGl.shaderSource (shader, source);
	contextGl.compileShader (shader);
	// Vérifier s'il a ét compilé avec succès
	if (!contextGl.getShaderParameter (shader, contextGl.COMPILE_STATUS)){
		alert ("An error occurred compiling the shaders: " + contextGl.getShaderInfoLog (shader));
		contextGl.deleteShader (shader);
		return null;
	}
	return shader;
}
function initShaderProgram (contextGl, shaderSommetSrc, shaderFragmentSrc){
	const shaderSommet = loadShader (contextGl, contextGl.VERTEX_SHADER, shaderSommetSrc);
	if (shaderSommet === null){
		alert ("le shader de sommet n'a pas put être créé");
		return null;
	}
	const shaderFragment = loadShader (contextGl, contextGl.FRAGMENT_SHADER, shaderFragmentSrc);
	if (shaderFragment === null){
		alert ("le shader de fragment n'a pas put être créé");
		return null;
	}
	const shaderProgram = contextGl.createProgram();
	contextGl.attachShader (shaderProgram, shaderSommet);
	contextGl.attachShader (shaderProgram, shaderFragment);
	contextGl.linkProgram (shaderProgram);
	// Si la création du programme shader a échoué, alerte
	if (!contextGl.getProgramParameter (shaderProgram, contextGl.LINK_STATUS)){
		alert ("Impossible d'initialiser le programme shader : " + contextGl.getProgramInfoLog (shaderProgram));
		return null;
	}
	return shaderProgram;
}
const shaderProgram = initShaderProgram (contextGl, shaderSommetSrc, shaderFragmentSrc);
const programInfo ={
	program: shaderProgram,
	attribLocations: { vertexPosition: contextGl.getAttribLocation (shaderProgram, 'aVertexPosition') },
	uniformLocations: {
		projectionMatrix: contextGl.getUniformLocation (shaderProgram, 'uProjectionMatrix'),
		modelViewMatrix: contextGl.getUniformLocation (shaderProgram, 'uModelViewMatrix'),
	},
};
const { mat2, mat2d, mat4, mat3, quat, quat2, vec2, vec3, vec4 } = glMatrix;
function initBuffers (contextGl){
	const positionBuffer = contextGl.createBuffer();
	// Définir le positionBuffer comme étant celui auquel appliquer les opérations de tampon à partir d'ici.
	contextGl.bindBuffer (contextGl.ARRAY_BUFFER, positionBuffer);
	const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];
	// Passer mainenant la liste des positions à WebcontextGl pour construire la forme.
	// Nous faisons cela en créant un Float32Array à partir du tableau JavaScript,
	// puis en l'utilisant pour remplir le tampon en cours.
	contextGl.bufferData (contextGl.ARRAY_BUFFER, new Float32Array(positions), contextGl.STATIC_DRAW);
	return { position: positionBuffer };
}
function drawScene (contextGl, programInfo, buffers){
	contextGl.clearColor (1.0, 0.0, 1.0, 1.0);
	contextGl.clearDepth (1.0);
	contextGl.enable (contextGl.DEPTH_TEST); // activer le test de profondeur
	contextGl.depthFunc (contextGl.LEQUAL); // les choses proches cachent les choses lointaines
	contextGl.clear (contextGl.COLOR_BUFFER_BIT | contextGl.DEPTH_BUFFER_BIT);
	// Créer une matrice de perspective, utilisée pour simuler la distorsion de la perspective dans une caméra.
	// Notre champ de vision est de 45 degrés, avec un rapport largeur / hauteur qui correspond à la taille d'affichage du canvas;
	// et nous voulons seulement voir les objets situés entre 0,1 unité et 100 unités à partir de la caméra.
	const fieldOfView =  (45 * Math.PI) / 180; // en radians
	const aspect = contextGl.canvas.clientWidth / contextGl.canvas.clientHeight;
	const zNear = 0.1;
	const zFar = 100.0;
//	var mat4 = glMatrix.mat4;	// importer gl-matrix pour avoir mat4. https://www.npmjs.com/package/gl-matrix
	const projectionMatrix = mat4.create();
	// note: contextGlmatrix.js a toujours comme premier argument la destination où stocker le résultat.
	mat4.perspective (projectionMatrix, fieldOfView, aspect, zNear, zFar);
	// Définir la position de dessin comme étant le point "origine", qui est
	// le centre de la scène.
	const modelViewMatrix = mat4.create();
	// Commencer maintenant à déplacer la position de dessin un peu vers là où
	// nous voulons commencer à dessiner le carré.
	mat4.translate (
		modelViewMatrix, // matrice de destination
		modelViewMatrix, // matrice de déplacement
		[-0.0, 0.0, -6.0],
	); // quantité de déplacement
	// Indiquer à WebcontextGl comment extraire les positions à partir du tampon des
	// positions pour les mettre dans l'attribut vertexPosition.
	{
		const numComponents = 2; // extraire 2 valeurs par itération
		const type = contextGl.FLOAT; // les données dans le tampon sont des flottants 32bit
		const normalize = false; // ne pas normaliser
		const stride = 0; // combien d'octets à extraire entre un jeu de valeurs et le suivant
		// 0 = utiliser le type et numComponents ci-dessus
		const offset = 0; // démarrer à partir de combien d'octets dans le tampon
		contextGl.bindBuffer (contextGl.ARRAY_BUFFER, buffers.position);
		contextGl.vertexAttribPointer (programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);
		contextGl.enableVertexAttribArray (programInfo.attribLocations.vertexPosition);
	}
	// Indiquer à WebcontextGl d'utiliser notre programme pour dessiner
	contextGl.useProgram (programInfo.program);
	// Définir les uniformes du shader
	contextGl.uniformMatrix4fv (programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
	contextGl.uniformMatrix4fv (programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
	{
		const offset = 0;
		const vertexCount = 4;
		contextGl.drawArrays (contextGl.TRIANcontextGlE_STRIP, offset, vertexCount);
	}
}
const buffers = initBuffers (contextGl);
drawScene (contextGl, programInfo, buffers);
</script></html>