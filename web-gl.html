<!DOCTYPE html><html><head>
	<title>éssais avec web gl</title>
	<base target='_blank'/>
	<meta charset='utf-8'/>
	<meta name='viewport' content='width=device-width, initial-scale=1'/>
	<meta name='subject' content='loisir'/>
	<meta name='author' content='deborah'/>
	<meta name='link' content='o'/>
	<link rel='stylesheet' type='text/css' href='file:///C:/wamp64/www/site-dp/library-css/structure.css'/>
	<link rel='stylesheet' type='text/css' href='file:///C:/wamp64/www/site-dp/library-css/perso.css' media='screen'/>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
		integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
		crossorigin="anonymous">
	</script>
</head><style type='text/css'>
	canvas{
		border: solid 4px var(--text-color);
		background-color: var(--fond-color);
	}
	h2{ border: none; }
</style><body>
	<canvas width='640' height='480'></canvas>
	<h2>sources</h2>
	<ul aria-label='sources'>
		<li><a href='https://developer.mozilla.org/fr/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL'>créer un contexte web gl</a></li>
		<li><a href='https://developer.mozilla.org/fr/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context'>dessin 2d</a></li>
		<li><a href=''></a></li>
	</ul>
</body><script type='text/javascript'>
	const figPoints =[ 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 0.0, -2.0 ];
	const figColor =[ 0.6, 1.0, 0.0, 1.0 ];
	const fondColor =[ 1.0, 0.0, 0.4, 1.0 ];
	drawInCanvas (figPoints, figColor, fondColor);

function loadShader (contextGl, type, source){
	const shader = contextGl.createShader (type);
	contextGl.shaderSource (shader, source);
	contextGl.compileShader (shader);
	if (! contextGl.getShaderParameter (shader, contextGl.COMPILE_STATUS)){
		alert (`An error occurred compiling the shaders: ${contextGl.getShaderInfoLog (shader)}`);
		contextGl.deleteShader (shader);
		return null;
	}
	return shader;
}
function drawInCanvas (figPoints, figColor, fondColor){
	const canvas = document.getElementsByTagName ('canvas')[0];
	// Initialize the GL context
	const contextGl = canvas.getContext ('webgl');
	// Only continue if WebGL is available and working
	if (contextGl === null){
		alert ("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	// Set clear color to black, fully opaque
	contextGl.clearColor (0.0, 0.0, 0.0, 1.0);
	// Clear the color buffer with specified clear color
	contextGl.clear (contextGl.COLOR_BUFFER_BIT);
	// Vertex shader program
	const shaderSommetSrc = `attribute vec4 aVertexPosition;
	uniform mat4 uModelViewMatrix;
	uniform mat4 uProjectionMatrix;
	void main(){ gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; }`;
	const shaderFragmentSrc = 'void main(){ gl_FragColor = vec4 ('+ figColor.toString() +'); }';
	// Initialize a shader program; this is where all the lighting for the vertices and so forth is established.
	const vertexShader = loadShader (contextGl, contextGl.VERTEX_SHADER, shaderSommetSrc);
	const fragmentShader = loadShader (contextGl, contextGl.FRAGMENT_SHADER, shaderFragmentSrc);
	const shaderProgram = contextGl.createProgram();
	contextGl.attachShader (shaderProgram, vertexShader);
	contextGl.attachShader (shaderProgram, fragmentShader);
	contextGl.linkProgram (shaderProgram);
	if (! contextGl.getProgramParameter (shaderProgram, contextGl.LINK_STATUS)){
		alert (`Unable to initialize the shader program: ${contextGl.getProgramInfoLog (shaderProgram)}`);
		return null;
	}
	// Collect all the info needed to use the shader program.
	// Look up which attribute our shader program is using for aVertexPosition and look up uniform locations.
	const programInfo ={
		program: shaderProgram,
		attribLocations:{ vertexPosition: contextGl.getAttribLocation (shaderProgram, "aVertexPosition" )},
		uniformLocations:{
			projectionMatrix: contextGl.getUniformLocation (shaderProgram, "uProjectionMatrix"),
			modelViewMatrix: contextGl.getUniformLocation (shaderProgram, "uModelViewMatrix" )
	}};
	// Here's where we call the routine that builds all the objects we'll be drawing.
	// créer le buffer des positions
	const positionBuffer = contextGl.createBuffer();
	// Select the positionBuffer as the one to apply buffer operations to from here out.
	contextGl.bindBuffer (contextGl.ARRAY_BUFFER, positionBuffer);
	// Now pass the list of positions into WebGL to build the shape. We do this by creating a Float32Array from the JavaScript array, then use it to fill the current buffer.
	contextGl.bufferData (contextGl.ARRAY_BUFFER, new Float32Array (figPoints), contextGl.STATIC_DRAW);
	const buffers ={ position: positionBuffer };
	// dessiner la scène
	contextGl.clearColor (fondColor[0], fondColor[1], fondColor[2], fondColor[3]); // Clear to black, fully opaque
	contextGl.clearDepth (1.0); // Clear everything
	contextGl.enable (contextGl.DEPTH_TEST); // Enable depth testing
	contextGl.depthFunc (contextGl.LEQUAL); // Near things obscure far things
	contextGl.clear (contextGl.COLOR_BUFFER_BIT | contextGl.DEPTH_BUFFER_BIT);
	// Create a perspective matrix, a special matrix that is used to simulate the distortion of perspective in a camera.
	// Our field of view is 45 degrees, with a width / height ratio that matches the display size of the canvas and we only want to see objects between 0.1 and 100 units away from the camera.
	const fieldOfView = (45 * Math.PI) / 180; // in radians
	const aspect = contextGl.canvas.clientWidth / contextGl.canvas.clientHeight;
	const zNear = 0.1;
	const zFar = 100.0;
	const projectionMatrix = mat4.create();
	// note: glmatrix.js always has the first argument as the destination to receive the result.
	mat4.perspective (projectionMatrix, fieldOfView, aspect, zNear, zFar);
	// Set the drawing position to the "identity" point, which is the center of the scene.
	const modelViewMatrix = mat4.create();
	// Now move the drawing position a bit to where we want to start drawing the square.
	mat4.translate (
		modelViewMatrix, // destination matrix
		modelViewMatrix, // matrix to translate
		[-0.0, 0.0, -6.0] // amount to translate
	);
	// Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute.
	const numComponents = 2; // pull out 2 values per iteration
	const type = contextGl.FLOAT; // the data in the buffer is 32bit floats
	const normalize = false; // don't normalize
	const stride = 0; // how many bytes to get from one set of values to the next. 0 = use type and numComponents above
	const offset = 0; // how many bytes inside the buffer to start from
	contextGl.bindBuffer (contextGl.ARRAY_BUFFER, buffers.position);
	contextGl.vertexAttribPointer (programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);
	contextGl.enableVertexAttribArray (programInfo.attribLocations.vertexPosition);
	// utiliser le programme
	contextGl.useProgram (programInfo.program);
	// Set the shader uniforms
	contextGl.uniformMatrix4fv (programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
	contextGl.uniformMatrix4fv (programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
	const vertexCount = figPoints.length /2;
	contextGl.drawArrays (contextGl.TRIANGLE_STRIP, offset, vertexCount);
}
</script></html>